# РАЗРАБОТКА ИГРОВЫХ СЕРВИСОВ
Отчет по лабораторной работе #3 выполнил(а):
- Кыров Валентин Сергеевич
- 1922524
Отметка о выполнении заданий (заполняется студентом):

| Задание | Выполнение | Баллы |
| ------ | ---------- | ------ |
| Задание 1 | *          | 60 |
| Задание 2 | *          | 20 |
| Задание 3 | *          | 20 |

знак "*" - задание выполнено; знак "#" - задание не выполнено;

Работу проверили:
- к.т.н., доцент Денисов Д.В.
- к.э.н., доцент Панов М.А.
- ст. преп., Фадеев В.О.


## Цель работы
Интеграция интерфейса пользователя в разрабатываемое интерактивное приложение.

## Задание 
### Используя видео-материалы практических работ повторить реализацию игровых механик
+ Реализация механизма ловли объектов
+ Реализация графического интерфейса с добавлением счетчика очков

Ход работы:  
0. Исходим из того, что в рамках лабораторной работы я продолжаю работать над своим проектом из лабораторной работы №2.
1. Если декомпозировать механику на составляющие, то выяснится, что она состоит из двух задач: настройка контроллера для основного GameObject и использование коллайдера как триггера к некоему действию (уничтожению другого объекта, триггеру счётчика очков, вызову анимации и т.д.)  
Так, за перемещение персонажа в моей игре отвечает скрипт PlayerController:
```csharp
using System.Collections;
using UnityEngine;
using UnityStandardAssets.CrossPlatformInput;

public class PlayerController : MonoBehaviour
{
    public Transform Character;
    public float maxSpeed = 6f; // горизонтальная скорость
    public float verticalSpeed = 20;
    [HideInInspector]
    public bool lookingRight = true;
    public GameObject Cloud;
    private Rigidbody2D rb2d;
    private Animator anim;
    void Start()
    {
        rb2d = GetComponent<Rigidbody2D>();
        anim = GetComponent<Animator>();
        Cloud = GameObject.Find("Cloud");
    }
    void OnCollisionEnter2D(Collision2D collision2D) // вызывает след от столкновения с объектами при падении
    {
        if (collision2D.relativeVelocity.magnitude > 5)
        {
            Cloud =
                Instantiate(Resources.Load("Prefabs/Cloud"),
                transform.position,
                transform.rotation) as
                GameObject;
        }
    }

    void FixedUpdate()
    {
        float hor = CrossPlatformInputManager.GetAxis("Horizontal");
        anim.SetFloat("Speed", Mathf.Abs(hor));
        rb2d.velocity = new Vector2(hor * maxSpeed, rb2d.velocity.y); // перемещение по оси x
        if ((hor > 0 && !lookingRight) || (hor < 0 && lookingRight)) Flip(); // поворот персонажа в другую сторону
        anim.SetFloat("vSpeed", GetComponent<Rigidbody2D>().velocity.y); // перемещение по оси y, в данном случае падение
    }
    public void Flip() // функция разворачивает персонажа в другую сторону
    {
        lookingRight = !lookingRight;
        Vector3 myScale = transform.localScale;
        myScale.x *= -1;
        transform.localScale = myScale;
    }
}

```
Также, в этом скрипте реализуется механика, связанная с коллайдером. В моём случае, при падении с достаточной высоты или с достаточной горизонтальной скоростью при столкновении создаётся след в виде облака, что отражает факт столкновения с объектом.  
Для перевода управления на клавиатуру я в Input Manager для горизонтальной оси выбрал способ управления "Key or Mouse Button".  
1. Графический интерфейс со счётчиком очков уже присутствовал в проекте, так как я его разработал ранее. Реализован он с помощью Canvas, на котором размещены различные элементы:
+ Счётчик очков (в моём случае очки = время, проведённое в игровой сессии, где 1 секунда = 10 очков)
+ Cчётчик высоты, на которой находится персонаж (при достижении 10000 метров игра заканчивается, и появляется экран благодарности за игру)
+ Кнопка паузы, которая активирует соответствующий экран, из которого можно продолжить игру, начать её заново или выйти в главное меню.
+ Всплывающий текст при достижении определённой высоты, работает как при падении, так и при наборе высоты.  
![](https://github.com/clzhckr/GameServices_URFU/blob/main/Lab3/Media/OverviewUI.png)
![](https://github.com/clzhckr/GameServices_URFU/blob/main/Lab3/Media/PauseUI.png)
## Задание 2
### Используя видео-материалы практических работ повторить реализацию игровых механик
+ Уменьшение жизни. Добавление текстур
+ Структурирование исходных файлов в папке
2. Интерпретировать механику уменьшения жизни я решил с помощью изменения ускорения свободного падения для персонажа. Чем выше он поднимается, тем меньше это значение становится, и тем медленнее он будет падать, что быстрее приведёт к концу игры.
  Реализовано это в соответствующем скрипте счётчика высоты в функции `Update()`
  ```csharp
    high = Character.position.y * 5;
        HighText.text = high.ToString("0") + "m"; //счётчик высоты берётся из кооридинаты игрока по оси Y

        if (high < 1500)
        {
            Finish.SetActive(false);
            bg1.SetActive(true);
            bg2.SetActive(false); // переключение заднего фона по условию
        }

        if (high > 1500)
        {
            Character.GetComponent<Rigidbody2D>().gravityScale = 9f; // смена ускорения свободного падения по условию
            Tier.text = "Всё выше!"; // вывод текста о чекпоинте высоты
            bg1.SetActive(false);
            bg2.SetActive(true);
            bg3.SetActive(false);
        }
  ```
1. В соответствии с рекомендациями из видео я отредактировал структуру папок в проекте: 
 ![](https://github.com/clzhckr/GameServices_URFU/blob/main/Lab3/Media/ProjectAssets.png)
## Задание 3
### Используя видео-материалы практических работ интегрировать игровой сервис в готовое приложение
1. На [просторах интернета](https://t.me/yandexgame_plugin/5901) я нашёл плагин, используемый в видео, затем я добавил его в проект drag-n-drop'ом. В файлах проекта появилась отдельная папка YandexGame.
2. В соответствии с рекомендациями на видео, в каждую сцену, которая будет билдиться, я добавил Gameobject YandexGame.
3. Также я настроил качество освещения и снял галочку с "Development Build", так как плагины разработки в билде увеличивают его размер.
4. Затем я добавил проект как черновик на Яндекс.Игры
![](https://github.com/clzhckr/GameServices_URFU/blob/main/Lab3/Media/YandexTest.png)



## Выводы

В ходе работы я отредактировал созданный в рамках предыдущих лабораторных работ пользовательский интерфейс для большего удобства игрового процесса и общей привлекательности игры, а также подключил дополнительные инструменты SDK Яндекс.Игр для расширения функционала в рамках сервиса Яндекс.Игры.

